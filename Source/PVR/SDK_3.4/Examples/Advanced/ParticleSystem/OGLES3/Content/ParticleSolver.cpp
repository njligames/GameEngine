// This file was created by Filewrap 1.2
// Little endian mode
// DO NOT EDIT

#include "../PVRTMemoryFileSystem.h"

// using 32 bit to guarantee alignment.
#ifndef A32BIT
 #define A32BIT static const unsigned int
#endif

// ******** Start: ParticleSolver.csh ********

// File data
static const char _ParticleSolver_csh[] = 
	"#version 310 es\r\n"
	"\r\n"
	"\r\n"
	"//Please #define WORKGROUP_SIZE from the code side\r\n"
	"\r\n"
	"//Minimum lifetime of particle\r\n"
	"#define MIN_TTL .5\r\n"
	"//Variance of particle lifetime\r\n"
	"#define MAX_ADDITIONAL_TTL 1.\r\n"
	"\r\n"
	"//Binding points\r\n"
	"#define PARTICLES_SSBO_BINDING 1\r\n"
	"#define SPHERES_UBO_BINDING 2\r\n"
	"#define CONFIG_UNIFORM_BINDING 3\r\n"
	"\r\n"
	"//Arbitrary factors to make physics work in a visually pleasing way\r\n"
	"#define TIME_FACTOR .1\r\n"
	"#define VELOCITY_FACTOR 4.\r\n"
	"\r\n"
	"#define numSpheres 8u\r\n"
	"\r\n"
	"// Struct declarations to have a nice representation of the data layout.\r\n"
	"// Please be aware of the alignment restrictions (e.g. sizeof(vec3) == sizeof(vec4)) that are defined in the GLSL specification.\r\n"
	"// Because of that we need to be very careful, and upload the data in a controllable way from the CPU (e.g. using std140 packing,\r\n"
	"// packing manually float values in quads and reading as vectors et.c.).\r\n"
	"\r\n"
	"//Padding could be calculated instead of being explicitly added with std149, but it helps catch errors easier.\r\n"
	"struct Particle\r\n"
	"{\t\r\n"
	"\thighp vec3 vPosition;\t\t\t\r\n"
	"\thighp float _padding_particle_0;\r\n"
	"\thighp vec3 vVelocity;\r\n"
	"\thighp float fLife;\r\n"
	"};\r\n"
	"\r\n"
	"struct Emitter\r\n"
	"{\r\n"
	"\thighp mat4  mTransformation;\r\n"
	"\thighp float    fHeight;\r\n"
	"\thighp float    fRadius;\r\n"
	"};\r\n"
	"\r\n"
	"layout(std140, binding=PARTICLES_SSBO_BINDING) buffer SsboParticlesIn\r\n"
	"{\r\n"
	"\tParticle aParticles[];\r\n"
	"};\r\n"
	"\r\n"
	"layout(std140, binding=SPHERES_UBO_BINDING) uniform UboSpheres\r\n"
	"{\r\n"
	"\thighp vec4 aSpheres[8];\r\n"
	"};\r\n"
	"\r\n"
	"layout(std140, binding=CONFIG_UNIFORM_BINDING) uniform UboData\r\n"
	"{\r\n"
	"\tEmitter emitter;\r\n"
	"\thighp vec3 vG;\r\n"
	"\thighp float fDt;\r\n"
	"\thighp float fTotalTime;\r\n"
	"};\r\n"
	"\r\n"
	"highp float last_random;\r\n"
	"void seed_random(highp float seed)\r\n"
	"{\r\n"
	"\tlast_random = seed;\r\n"
	"}\r\n"
	"\r\n"
	"float randf()\r\n"
	"{\r\n"
	"\t//This is not random at all, and was chosen for looking nice and nothing else.\r\n"
	"\t//The last *100 is cheating - we want the pattern to discretize a bit to create the \"magnetic field\" lines\r\n"
	"\t//So, we effectively discard a few decimal precision points by \"fract\" that way...\r\n"
	"\t//If you want more uniform distribution, remove *100 or (or even replace it by .1)\r\n"
	"\tlast_random = fract((last_random * 393.2312 + .2318453) * 100.);\r\n"
	"\treturn last_random;\r\n"
	"}\r\n"
	"\r\n"
	"// Emits the aParticles[gid] at a random position within the emitter params\r\n"
	"Particle EmitParticle(Emitter emitter)\r\n"
	"{\t\r\n"
	"\t// Generate random parameters for spawn position calculations\r\n"
	"\thighp float u = randf() * emitter.fHeight;\r\n"
	"\thighp float r = randf() * emitter.fRadius;\r\n"
	"\t\r\n"
	"\t//We need pos to be a vec4 so we can transform it using the emitter's transformation\r\n"
	"\tvec4 pos = vec4(r, u, r,1);\r\n"
	"\t\r\n"
	"\tParticle particle;\r\n"
	"\t// Transform according to emitter orientation\r\n"
	"\t\r\n"
	"\tpos = emitter.mTransformation * pos;\r\n"
	"\tparticle.vPosition = pos.xyz / pos.w;\r\n"
	"\r\n"
	"\t// Give it random speed (the origin is assumed to be at the origin, otherwise adapt code below)\r\n"
	"\tparticle.vVelocity = particle.vPosition * randf() * 8.0f + vec3(0,20,0);\r\n"
	"\treturn particle;\r\n"
	"}\r\n"
	"\r\n"
	"// Main kernel entry point. Simulates the aParticles[gid] movement and collides it against collider geometry (fixed ground plane at y=0).\r\n"
	"layout (local_size_x = WORKGROUP_SIZE) in;\r\n"
	"void main()\r\n"
	"{\r\n"
	"\tuint gid = gl_GlobalInvocationID.x;\r\n"
	"\tuint lid = gl_LocalInvocationID.x;\r\n"
	"\t\r\n"
	"\tseed_random(mod(fTotalTime + float(gid) + 1000000., 10.123123));\r\n"
	"\t\r\n"
	"\t/*We remove the following bounds check because our code has made sure that the particles are a multiple of our workgroup*/\r\n"
	"\t//const uint numParticles = 131072; //or numParticles passed as a uniform, or as a compile-time constant\r\n"
	"\t//if (gid >= numParticles) return; \r\n"
	"\r\n"
	"\t//Load a particle's values in a register.\r\n"
	"\tParticle particle = aParticles[gid];\r\n"
	"\r\n"
	"\thighp float life = particle.fLife;\r\n"
	"\r\n"
	"\t//Reduce it's lifetime ( 0 < life < in the order of 1)\r\n"
	"\tlife -= fDt * TIME_FACTOR;\r\n"
	"\t\t\r\n"
	"\t//Respawn if particle is dead \r\n"
	"\tif (life < .0)\t\t\r\n"
	"\t{\r\n"
	"\t\tparticle = EmitParticle(emitter);\r\n"
	"\t\tlast_random = life = randf() * MAX_ADDITIONAL_TTL + MIN_TTL;\r\n"
	"\t}\r\n"
	"\telse\r\n"
	"\t{\r\n"
	"\t\thighp vec3 v = particle.vVelocity;\r\n"
	"\r\n"
	"\t\t//Simulate particle movement: \r\n"
	"\t\t//Semi-implicit euler is the best of the \"completely basic\", forward integration methods - it has better\r\n"
	"\t\t//behaviour than explicit Euler basically for free. Error is of the same order as Explicit Euler, but it \r\n"
	"\t\t//is much more stable as it normally retains energy.\r\n"
	"\t\t//Explicit Euler is\t\t: x1 = x0 + v0.dt, then: v1 = v0 + a0*dt\r\n"
	"\t\t//Semi - Implicit euler is \r\n"
	"\t\t//This integration is\t: v1 = v0 + a0*dt, then: x1 = x0 + v1*dt (we will use this)\r\n"
	"\t\t//OR\t\t\t\t\t: x1 = x0 + v0*dt, then: v1 = v0 + a1*dt\r\n"
	"\r\n"
	"\t\t//a0 = g. Update velocity due to a. \r\n"
	"\t\tv = (vG * fDt) + v;\r\n"
	"\r\n"
	"\t\t//Do the last part of the semi-implicit Euler : \r\n"
	"\t\tparticle.vPosition = v * fDt + particle.vPosition;\r\n"
	"\r\n"
	"\t\t//Then, collide against the spheres (very fake, but looks convincing)\r\n"
	"\t\tfor (uint i=0u; i < numSpheres; i++)\r\n"
	"\t\t{\r\n"
	"\t\t\t// Fetch sphere attributes (position=sphereDef.xyz, radius=sphereDef.w)\r\n"
	"\t\t\tvec4 sphereDef = aSpheres[i];\r\n"
	"\t\t\t\t\t\t\r\n"
	"\t\t\t//Check whether particle penetrated the sphere. Reuse calculations as much as possible.\r\n"
	"\t\t\t//Normally, we would just go ahead and use length(), but at this point we will probably\r\n"
	"\t\t\t//be using a lot of the intermediates as well.\r\n"
	"\t\t\tvec3 sphere_to_next_pos = particle.vPosition - sphereDef.xyz;\r\n"
	"\t\t\tfloat distanceSq = dot(sphere_to_next_pos,sphere_to_next_pos);\r\n"
	"\r\n"
	"\t\t\tif (distanceSq < sphereDef.w * sphereDef.w)\r\n"
	"\t\t\t{\t\t\t\r\n"
	"\t\t\t\tfloat rDist = inversesqrt(distanceSq);\r\n"
	"\t\t\t\t//Project it back to sphere surface and do a very simple and fast velocity inversion\r\n"
	"\t\t\t\t//vec3 dir_to_circle = sphere_to_next_pos / sphere_to_next_pos_length;\r\n"
	"\t\t\t\tvec3 dir_to_circle = sphere_to_next_pos * rDist;\r\n"
	"\t\t\t\tparticle.vPosition = dir_to_circle * sphereDef.w + sphereDef.xyz;\r\n"
	"\t\t\t\tv = dir_to_circle * length(v) * 0.5f;\r\n"
	"\t\t\t\t// One collision is enough\r\n"
	"\t\t\t\tbreak;\r\n"
	"\t\t\t}\t\t\t\r\n"
	"\t\t}\r\n"
	"\t\t\r\n"
	"\t\t// Collide against ground plane\r\n"
	"\t\tif (particle.vPosition.y < 0.0f)\r\n"
	"\t\t{\r\n"
	"\t\t//\t//x & z coeffs represent a sort of friction, y represents reflection -- As always, we can\r\n"
	"\t\t//\t//use a model that is as physically correct or incorrect as is appropriate for our use\r\n"
	"\t\t\tconst vec3 reflectCoeffs = vec3(0.4f, -0.3f, 0.4f);\r\n"
	"\t\t\tparticle.vPosition.y = -particle.vPosition.y;\r\n"
	"\t\t\tv *= reflectCoeffs;\r\n"
	"\t\t}\r\n"
	"\r\n"
	"\t\t//Pack velocity back\r\n"
	"\t\tparticle.vVelocity = v;\r\n"
	"\t}\r\n"
	"\t//Pack life back\r\n"
	"\tparticle.fLife = life;\r\n"
	"\t\r\n"
	"\t//Write to global memory\r\n"
	"\taParticles[gid] = particle;\r\n"
	"\r\n"
	"\t//We do not synchronize as there is absolutely no interaction between particles in that case\r\n"
	"}\r\n";

// Register ParticleSolver.csh in memory file system at application startup time
static CPVRTMemoryFileSystem RegisterFile_ParticleSolver_csh("ParticleSolver.csh", _ParticleSolver_csh, 6420);

// ******** End: ParticleSolver.csh ********

