// This file was created by Filewrap 1.2
// Little endian mode
// DO NOT EDIT

#include "../PVRTMemoryFileSystem.h"

// using 32 bit to guarantee alignment.
#ifndef A32BIT
 #define A32BIT static const unsigned int
#endif

// ******** Start: effect.pfx ********

// File data
static const char _effect_pfx[] = 
	"[HEADER]\n"
	"\tVERSION\t\t01.00.00.00\n"
	"\tDESCRIPTION OGLES3DeferredShading\n"
	"\tCOPYRIGHT\tImagination Technologies\n"
	"[/HEADER]\n"
	"\n"
	"///////////////////////////////////////////////////////////////////////////\n"
	"////                                                                   ////\n"
	"////                   GBUFFER RENDER                                  ////\n"
	"////                                                                   ////\n"
	"///////////////////////////////////////////////////////////////////////////\n"
	"\n"
	"\n"
	"[VERTEXSHADER]\n"
	"\tNAME \t\tGBufferVertexShader\n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tattribute highp   vec3 inVertex;\n"
	"\t\tattribute highp   vec3 inNormal;\n"
	"\t\tattribute mediump vec2 inTexCoord;\n"
	"\t\tattribute highp   vec3 inTangent;\n"
	"\n"
	"\t\tuniform  mat4  uWorldViewProjMatrix; \n"
	"\t\tuniform  mat4  uWorldViewMatrix; \n"
	"\t\tuniform  mat4  uViewProjMatrix;\n"
	"\t\tuniform  mat4  uViewMatrix;\n"
	"\t\tuniform  mat3  uWorldViewIT; \n"
	"\n"
	"\t\tvarying  mediump  vec2   vTexCoord;\n"
	"\t\tvarying  highp    vec3   vNormal;\n"
	"\t\tvarying  highp    vec3   vTangent;\n"
	"\t\tvarying  highp    vec3   vBinormal;\n"
	"\t\tvarying  highp    vec3   vViewPos;\n"
	"\n"
	"\t\tvoid main() \n"
	"\t\t{\n"
	"\t\t\tgl_Position = uWorldViewProjMatrix * vec4(inVertex, 1.0);\n"
	"\t  \n"
	"\t\t\t// Transform normal from model space to eye space\n"
	"\t\t\tvNormal = uWorldViewIT * inNormal;\n"
	"\t\t\tvTangent = uWorldViewIT * inTangent;\n"
	"\t\t\tvBinormal = cross(vNormal, vTangent);\n"
	"\t  \n"
	"\t\t\t// Pass the vertex position in view space for depth calculations\n"
	"\t\t\tvViewPos = (uWorldViewMatrix * vec4(inVertex, 1.0)).xyz;\n"
	"\t\n"
	"\t\t\t// Pass the texture coordinates to the fragment shader\n"
	"\t\t\tvTexCoord = inTexCoord;\t\t\t\t\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/VERTEXSHADER]\n"
	" \n"
	"//\n"
	"// Effect to render the scene using a cube shadow map\n"
	"//\n"
	"[EFFECT] \n"
	"\tNAME \tRenderAlbedo\n"
	"\t\t\n"
	"\t// GLOBALS UNIFORMS\n"
	"\tUNIFORM uWorldViewProjMatrix\tWORLDVIEWPROJECTION\n"
	"\tUNIFORM uWorldViewMatrix\t\tWORLDVIEW\n"
	"\tUNIFORM uViewProjMatrix\t\t\tVIEWPROJECTION\n"
	"\tUNIFORM uViewMatrix\t\t\t\tVIEW\n"
	"\tUNIFORM uWorldViewIT\t\t \tWORLDVIEWIT\n"
	"\t\t\n"
	"\tUNIFORM sTexture\t\t\t\tTEXTURE0\n"
	"\tUNIFORM sBumpMap\t\t\t\tTEXTURE1\n"
	"\t\n"
	"\t// ATTRIBUTES\n"
	"\tATTRIBUTE inVertex\t\t\t\tPOSITION\n"
	"\tATTRIBUTE\tinNormal\t\t\tNORMAL\n"
	"\tATTRIBUTE\tinTexCoord\t\t\tUV\n"
	"\tATTRIBUTE\tinTangent\t\t\tTANGENT\n"
	"\tATTRIBUTE\tinBoneIndex\t\t\tBONEINDEX\n"
	"\tATTRIBUTE\tinBoneWeights\t\tBONEWEIGHT\n"
	"\t\n"
	"\t// CUSTOM SEMANTICS\n"
	"\tUNIFORM uFarClipDistance\t\t\tCUSTOMSEMANTIC_FARCLIPDISTANCE\n"
	"\t\t\n"
	"\tUNIFORM uSpecularPower\t\t\t\tCUSTOMSEMANTIC_SPECULARPOWER\n"
	"\tUNIFORM uDiffuseColour\t\t\t\tCUSTOMSEMANTIC_DIFFUSECOLOUR\n"
	"\t\t\n"
	"\t// SHADERS\n"
	"\tVERTEXSHADER   GBufferVertexShader\n"
	"\tFRAGMENTSHADER AlbedoFragmentShader\n"
	"[/EFFECT]\n"
	"\n"
	"[FRAGMENTSHADER] \n"
	"\tNAME \t\tAlbedoFragmentShader \n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tuniform  sampler2D  sTexture;\n"
	"\t\tuniform  sampler2D  sBumpMap;\n"
	"\n"
	"\t\tuniform  highp float  uFarClipDistance;\n"
	"\t\tuniform  lowp  float  uSpecularPower;\n"
	"\t\tuniform  lowp  vec3   uDiffuseColour;\n"
	"\n"
	"\t\tvarying  mediump vec2   vTexCoord;\n"
	"\t\tvarying  highp   vec3   vNormal;\n"
	"\t\tvarying  highp   vec3   vTangent;\n"
	"\t\tvarying  highp   vec3   vBinormal;\n"
	"\t\tvarying  highp   vec3   vViewPos;\n"
	"\t\t\n"
	"\t\tvoid main() \n"
	"\t\t{\n"
	"\t\t\t// Calculate the albedo\n"
	"\t\t\tlowp vec3 albedo = texture2D(sTexture, vTexCoord).rgb * uDiffuseColour;\n"
	"\t\t\t// Pack the specular exponent with the albedo\n"
	"\t\t\tgl_FragColor = vec4(albedo, uSpecularPower);\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/FRAGMENTSHADER]\n"
	"\n"
	"//\n"
	"// Effect to render the scene using a cube shadow map\n"
	"//\n"
	"[EFFECT] \n"
	"\tNAME \tRenderNormals\n"
	"\t\t\n"
	"\t// GLOBALS UNIFORMS\n"
	"\tUNIFORM uWorldViewProjMatrix\tWORLDVIEWPROJECTION\n"
	"\tUNIFORM uWorldViewMatrix\t\tWORLDVIEW\n"
	"\tUNIFORM uViewProjMatrix\t\t\tVIEWPROJECTION\n"
	"\tUNIFORM uViewMatrix\t\t\t\tVIEW\n"
	"\tUNIFORM uWorldViewIT\t\t \tWORLDVIEWIT\n"
	"\t\t\n"
	"\tUNIFORM sTexture\t\t\t\tTEXTURE0\n"
	"\tUNIFORM sBumpMap\t\t\t\tTEXTURE1\n"
	"\t\n"
	"\t// ATTRIBUTES\n"
	"\tATTRIBUTE inVertex\t\t\t\tPOSITION\n"
	"\tATTRIBUTE\tinNormal\t\t\tNORMAL\n"
	"\tATTRIBUTE\tinTexCoord\t\t\tUV\n"
	"\tATTRIBUTE\tinTangent\t\t\tTANGENT\n"
	"\tATTRIBUTE\tinBoneIndex\t\t\tBONEINDEX\n"
	"\tATTRIBUTE\tinBoneWeights\t\tBONEWEIGHT\n"
	"\t\n"
	"\t// CUSTOM SEMANTICS\n"
	"\tUNIFORM uFarClipDistance\t\t\tCUSTOMSEMANTIC_FARCLIPDISTANCE\n"
	"\t\t\n"
	"\tUNIFORM uSpecularPower\t\t\t\tCUSTOMSEMANTIC_SPECULARPOWER\n"
	"\tUNIFORM uDiffuseColour\t\t\t\tCUSTOMSEMANTIC_DIFFUSECOLOUR\n"
	"\t\t\n"
	"\t// SHADERS\n"
	"\tVERTEXSHADER   GBufferVertexShader\n"
	"\tFRAGMENTSHADER NormalFragmentShader\n"
	"[/EFFECT]\n"
	"\n"
	"[FRAGMENTSHADER] \n"
	"\tNAME \t\tNormalFragmentShader \n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tuniform  sampler2D  sBumpMap;\n"
	"\n"
	"\t\tuniform  highp float  uFarClipDistance;\n"
	"\t\tuniform  lowp  float  uSpecularPower;\n"
	"\t\tuniform  lowp  vec3   uDiffuseColour;\n"
	"\n"
	"\t\tvarying  mediump vec2   vTexCoord;\n"
	"\t\tvarying  highp   vec3   vNormal;\n"
	"\t\tvarying  highp   vec3   vTangent;\n"
	"\t\tvarying  highp   vec3   vBinormal;\n"
	"\t\tvarying  highp   vec3   vViewPos;\n"
	"\n"
	"\t\tvoid main() \n"
	"\t\t{\n"
	"\t\t\t// Calculate viewspace perturbed normal\n"
	"\t\t\thighp vec3 bumpmap = normalize(texture2D(sBumpMap, vTexCoord).rgb * 2.0 - 1.0);\n"
	"\t\t\thighp mat3 tangentSpace = mat3(normalize(vTangent), normalize(vBinormal), normalize(vNormal));\t\n"
	"\t\t\thighp vec3 normalVS = tangentSpace * bumpmap;\t\t\n"
	"\n"
	"\t\t\t// Scale the normal range from [-1,1] to [0, 1] to pack it into the RGB_U8 texture\n"
	"\t\t\tgl_FragColor.xyz = normalVS * 0.5 + 0.5;\t\n"
	"\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/FRAGMENTSHADER]\n"
	"\n"
	"//\n"
	"// Effect to render the scene depth and split it up into RGBA channels\n"
	"//\n"
	"[EFFECT] \n"
	"\tNAME \tRenderDepthChannelSplit\n"
	"\t\t\n"
	"\t// GLOBALS UNIFORMS\n"
	"\tUNIFORM uWorldViewProjMatrix\tWORLDVIEWPROJECTION\n"
	"\tUNIFORM uWorldViewMatrix\t\tWORLDVIEW\n"
	"\tUNIFORM uViewProjMatrix\t\t\tVIEWPROJECTION\n"
	"\tUNIFORM uViewMatrix\t\t\t\tVIEW\n"
	"\tUNIFORM uWorldViewIT\t\t \tWORLDVIEWIT\n"
	"\t\t\n"
	"\tUNIFORM sTexture\t\t\t\tTEXTURE0\n"
	"\tUNIFORM sBumpMap\t\t\t\tTEXTURE1\n"
	"\t\n"
	"\t// ATTRIBUTES\n"
	"\tATTRIBUTE inVertex\t\t\t\tPOSITION\n"
	"\tATTRIBUTE\tinNormal\t\t\tNORMAL\n"
	"\tATTRIBUTE\tinTexCoord\t\t\tUV\n"
	"\tATTRIBUTE\tinTangent\t\t\tTANGENT\n"
	"\t\n"
	"\t// CUSTOM SEMANTICS\n"
	"\tUNIFORM uFarClipDistance\t\t\tCUSTOMSEMANTIC_FARCLIPDISTANCE\n"
	"\t\t\n"
	"\tUNIFORM uSpecularPower\t\t\t\tCUSTOMSEMANTIC_SPECULARPOWER\n"
	"\tUNIFORM uDiffuseColour\t\t\t\tCUSTOMSEMANTIC_DIFFUSECOLOUR\n"
	"\t\t\n"
	"\t// SHADERS\n"
	"\tVERTEXSHADER   GBufferVertexShader\n"
	"\tFRAGMENTSHADER ChannelSplitDepthFragmentShader\n"
	"[/EFFECT]\n"
	"\n"
	"[FRAGMENTSHADER] \n"
	"\tNAME \t\tChannelSplitDepthFragmentShader \n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tuniform  highp float  uFarClipDistance;\n"
	"\n"
	"\t\tvarying  highp   vec3   vViewPos;\n"
	"\t\t\t\t\n"
	"\t\tvoid main() \n"
	"\t\t{\t\t\n"
	"\t\t\t// Pack the depth value into 4 channels \t\n"
	"\t\t\thighp float scaledDepth = length(vViewPos) / uFarClipDistance;\n"
	"\t\t\thighp vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * scaledDepth;\n"
	"\t\t\tenc = fract(enc);\n"
	"\t\t\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\t\t\t\n"
	"\t\t\t\n"
	"\t\t\tgl_FragColor = enc;\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/FRAGMENTSHADER]\n"
	"\n"
	"//\n"
	"// Effect to render the scene depth and exaggerate the actual depth\n"
	"//\n"
	"[EFFECT] \n"
	"\tNAME \tRenderDepth\n"
	"\t\t\n"
	"\t// GLOBALS UNIFORMS\n"
	"\tUNIFORM uWorldViewProjMatrix\tWORLDVIEWPROJECTION\n"
	"\tUNIFORM uWorldViewMatrix\t\tWORLDVIEW\n"
	"\tUNIFORM uViewProjMatrix\t\t\tVIEWPROJECTION\n"
	"\tUNIFORM uViewMatrix\t\t\t\tVIEW\n"
	"\tUNIFORM uWorldViewIT\t\t \tWORLDVIEWIT\n"
	"\t\t\n"
	"\tUNIFORM sTexture\t\t\t\tTEXTURE0\n"
	"\tUNIFORM sBumpMap\t\t\t\tTEXTURE1\n"
	"\t\n"
	"\t// ATTRIBUTES\n"
	"\tATTRIBUTE inVertex\t\t\t\tPOSITION\n"
	"\tATTRIBUTE\tinNormal\t\t\tNORMAL\n"
	"\tATTRIBUTE\tinTexCoord\t\t\tUV\n"
	"\tATTRIBUTE\tinTangent\t\t\tTANGENT\n"
	"\t\n"
	"\t// CUSTOM SEMANTICS\n"
	"\tUNIFORM uFarClipDistance\t\t\tCUSTOMSEMANTIC_FARCLIPDISTANCE\n"
	"\t\t\n"
	"\tUNIFORM uSpecularPower\t\t\t\tCUSTOMSEMANTIC_SPECULARPOWER\n"
	"\tUNIFORM uDiffuseColour\t\t\t\tCUSTOMSEMANTIC_DIFFUSECOLOUR\n"
	"\t\t\n"
	"\t// SHADERS\n"
	"\tVERTEXSHADER   GBufferVertexShader\n"
	"\tFRAGMENTSHADER DepthFragmentShader\n"
	"[/EFFECT]\n"
	"\n"
	"[FRAGMENTSHADER] \n"
	"\tNAME \t\tDepthFragmentShader \n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tuniform  highp float  uFarClipDistance;\n"
	"\n"
	"\t\tvarying  highp   vec3   vViewPos;\n"
	"\t\t\t\t\n"
	"\t\tvoid main() \n"
	"\t\t{\t\t\n"
	"\t\t\t// Pack the depth value into 4 channels \t\n"
	"\t\t\thighp float scaledDepth = length(vViewPos) / uFarClipDistance;\n"
	"\t\t\tgl_FragColor = vec4(vec3(scaledDepth * 5.0), 1.0);\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/FRAGMENTSHADER]\n"
	"\n"
	"///////////////////////////////////////////////////////////////////////////\n"
	"////                                                                   ////\n"
	"////                   DEFERRED LIGHT SHADERS                          ////\n"
	"////                                                                   ////\n"
	"///////////////////////////////////////////////////////////////////////////\n"
	"\n"
	"// \n"
	"// Vertex shader that is shared amongst (most) deferred light shaders\n"
	"//\n"
	"[VERTEXSHADER]\n"
	"\tNAME \t\tDeferredVertexShader\n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tattribute highp   vec3 inVertex;\n"
	"\n"
	"\t\tuniform  mat4  uWorldViewProjMatrix;\n"
	"\t\tuniform  mat4  uWorldViewMatrix;\n"
	"\t\t\n"
	"\t\tvarying  highp   vec3  vPositionVS;\n"
	"\t\tvarying  highp   vec3  vViewDirVS;\n"
	"\t\tvarying  mediump vec2  vTexCoord;\n"
	"\n"
	"\t\tvoid main() \n"
	"\t\t{ \t\n"
	"\t\t\tgl_Position = uWorldViewProjMatrix * vec4(inVertex, 1.0);\n"
	"\t\t\tgl_Position.xyz = gl_Position.xyz / gl_Position.w;\n"
	"\t\t\tgl_Position.w = 1.0;\n"
	"\t\t\t\n"
	"\t\t\tvTexCoord = (gl_Position.xy + 1.0) * 0.5;\n"
	"\t\n"
	"\t\t\t// Calculate the view-space position for lighting calculations\n"
	"\t\t\tvPositionVS = (uWorldViewMatrix * vec4(inVertex, 1.0)).xyz;\n"
	"\n"
	"\t\t\t// Pass the view direction\n"
	"\t\t\tvViewDirVS = vPositionVS;\n"
	"\t\t} \n"
	"\t[/GLSL_CODE]\n"
	"[/VERTEXSHADER]\n"
	"\n"
	"//\n"
	"// Calculates the lighting for a point light source\n"
	"//\n"
	"[EFFECT] \n"
	"\tNAME \tRenderPointLight\n"
	"\t\t\n"
	"\t// GLOBALS UNIFORMS\n"
	"\tUNIFORM uWorldViewProjMatrix\t\tWORLDVIEWPROJECTION\n"
	"\tUNIFORM uWorldViewMatrix\t\t\tWORLDVIEW\n"
	"\tUNIFORM uWorldIT\t\t\t\t\tWORLDIT\n"
	"\tUNIFORM uLightColourIntensity\t\tLIGHTCOLOR\n"
	"\t\t\n"
	"\tUNIFORM sAlbedo\t\t\t\t\t\tTEXTURE0\n"
	"\tUNIFORM sNormals\t\t\t\t\tTEXTURE1\n"
	"\tUNIFORM sDepth\t\t\t\t\t\tTEXTURE2\n"
	"\tUNIFORM sLightEnvMap\t\t\t\tTEXTURE3\n"
	"\t\n"
	"\t// CUSTOM SEMANTICS\n"
	"\tUNIFORM uFarClipDistance\t\t\tCUSTOMSEMANTIC_FARCLIPDISTANCE\n"
	"\t\n"
	"\tUNIFORM uLightViewPosition\t\tCUSTOMSEMANTIC_POINTLIGHT_VIEWPOSITION\n"
	"\t\n"
	"\t// ATTRIBUTES\n"
	"\tATTRIBUTE inVertex\t\t\tPOSITION\n"
	"\n"
	"\t// SHADERS\t\n"
	"\tVERTEXSHADER   DeferredVertexShader\n"
	"\tFRAGMENTSHADER PointLightFragmentShader\n"
	"[/EFFECT]\n"
	"\n"
	"[FRAGMENTSHADER] \n"
	"\tNAME \t\tPointLightFragmentShader \n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tuniform  sampler2D    sAlbedo;\n"
	"\t\tuniform  sampler2D    sNormals;\n"
	"\t\tuniform  sampler2D    sDepth;\n"
	"\t\tuniform  samplerCube  sLightEnvMap;\n"
	"\n"
	"\t\tuniform  highp float  uFarClipDistance;\n"
	"\t\tuniform  highp vec3   uLightColourIntensity;\n"
	"\n"
	"\t\tuniform  highp mat3   uWorldIT;\t\t\n"
	"\t\tuniform  highp vec3   uLightViewPosition;\n"
	"\t\t\n"
	"\t\tvarying  highp   vec3  vPositionVS;\n"
	"\t\tvarying  highp   vec3  vViewDirVS;\n"
	"\t\tvarying  mediump vec2  vTexCoord;\n"
	"\n"
	"\t\tvoid main()\n"
	"\t\t{\n"
	"\t\t\t//\n"
	"\t\t\t// Read GBuffer attributes\n"
	"\t\t\t//\t\n"
	"\t\t\thighp vec4 depthTex = texture2D(sDepth, vTexCoord);\n"
	"\t\t\thighp vec4 albedoSpec = texture2D(sAlbedo, vTexCoord);\n"
	"\t\t\thighp vec3 normalTex = texture2D(sNormals, vTexCoord).xyz;\n"
	"\t\t\t\n"
	"\t\t\t// reconstruct original depth value\n"
	"\t\t\thighp float depth = dot(depthTex, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0));\n"
	"\t\t\t\n"
	"\t\t\t//\n"
	"\t\t\t// Reconstruct common vectors and world space position \n"
	"\t\t\t//\n"
	"\t\t\thighp vec3 positionVS = normalize(vPositionVS) * depth * uFarClipDistance;\t\n"
	"\t\t\thighp vec3 lightDirection = uLightViewPosition - positionVS;\n"
	"\t\t\tlowp  vec3 lightColour = textureCube(sLightEnvMap, uWorldIT * lightDirection).rgb;\n"
	"\t\t\thighp float invLightDistance = 1.0 / length(lightDirection);\n"
	"\t\t\tlightDirection *= invLightDistance;\n"
	"\t\n"
	"\t\t\t//\n"
	"\t\t\t// Calculate lighting terms\n"
	"\t\t\t//\n"
	"\t\t\thighp vec3 normal = normalize(normalTex * 2.0 - 1.0);\t\n"
	"\t\t\thighp float n_dot_l = max(dot(lightDirection, normal), 0.0);\t\n"
	"\t\t\thighp vec3 diffuse = n_dot_l * albedoSpec.rgb;\n"
	"\n"
	"\t\t\thighp vec3 viewDirection = normalize(vViewDirVS);\n"
	"\t\t\thighp vec3 reflectedLightDirection = reflect(lightDirection, normal);\n"
	"\t\t\thighp float v_dot_r = max(dot(viewDirection, reflectedLightDirection), 0.0);\n"
	"\t\t\tdiffuse += vec3(pow(v_dot_r, albedoSpec.a * 100.0));\n"
	"\t\n"
	"\t\t\thighp float attenuation = invLightDistance * invLightDistance;\n"
	"\t\t\tgl_FragColor = vec4(diffuse * uLightColourIntensity * attenuation * lightColour, 1.0);\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/FRAGMENTSHADER]\n"
	"\n"
	"//\n"
	"// Calculates the lighting for a directional light source\n"
	"//\n"
	"[EFFECT] \n"
	"\tNAME \tRenderDirectionalLight\n"
	"\t\t\n"
	"\t// GLOBALS UNIFORMS\n"
	"\tUNIFORM uLightColourIntensity\t\tLIGHTCOLOR\n"
	"\t\t\t\n"
	"\tUNIFORM sAlbedo\t\t\t\t\t\tTEXTURE0\n"
	"\tUNIFORM sNormals\t\t\t\t\tTEXTURE1\n"
	"\t\t\n"
	"\t// CUSTOM SEMANTICS\n"
	"\tUNIFORM uLightDirection\t\t\tCUSTOMSEMANTIC_DIRECTIONALLIGHT_DIRECTION\n"
	"\t\n"
	"\t// ATTRIBUTES\n"
	"\tATTRIBUTE inVertex\t\t\t\tPOSITION\n"
	"\tATTRIBUTE inTexCoord\t\t\tUV\n"
	"\n"
	"\t// SHADERS\t\n"
	"\tVERTEXSHADER   DirectionalLightVertexShader\n"
	"\tFRAGMENTSHADER DirectionalLightFragmentShader\n"
	"[/EFFECT]\n"
	"\n"
	"[VERTEXSHADER]\n"
	"\tNAME \t\tDirectionalLightVertexShader\n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tattribute highp   vec3 inVertex;\n"
	"\t\tattribute mediump vec2 inTexCoord;\n"
	"\n"
	"\t\tuniform  highp vec4  uLightDirection;\n"
	"\n"
	"\t\tvarying  highp   vec3  vLightDirection;\n"
	"\t\tvarying  mediump vec2  vTexCoord;\n"
	"\n"
	"\t\tvoid main() \n"
	"\t\t{ \t\n"
	"\t\t\tgl_Position = vec4(inVertex, 1.0);\n"
	"\n"
	"\t\t\tvTexCoord = inTexCoord;\n"
	"\t\t\tvLightDirection = uLightDirection.xyz;\n"
	"\t\t} \n"
	"\t[/GLSL_CODE]\n"
	"[/VERTEXSHADER]\n"
	"\n"
	"[FRAGMENTSHADER] \n"
	"\tNAME \t\tDirectionalLightFragmentShader \n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tuniform  sampler2D  sAlbedo;\n"
	"\t\tuniform  sampler2D  sNormals;\n"
	"\n"
	"\t\tuniform highp vec3  uLightColourIntensity;\n"
	"\n"
	"\t\tvarying highp   vec3 vLightDirection;\n"
	"\t\tvarying mediump vec2 vTexCoord;\n"
	"\n"
	"\t\tvoid main()\n"
	"\t\t{\n"
	"\t\t\t// Fetch required gbuffer attributes\n"
	"\t\t\tlowp  vec3 albedo = texture2D(sAlbedo, vTexCoord).rgb;\n"
	"\t\t\thighp vec3 normalTex = texture2D(sNormals, vTexCoord).xyz;\n"
	"\t\t\thighp vec3 normal = normalize(normalTex.xyz * 2.0 - 1.0);\n"
	"\t\t\t\n"
	"\t\t\t// Calculate simple diffuse lighting\n"
	"\t\t\thighp float n_dot_l = max(dot(-vLightDirection, normal.xyz), 0.0);\n"
	"\t\t\tlowp vec3 colour = albedo * n_dot_l * uLightColourIntensity;\n"
	"\t\t\t\t\t\t\n"
	"\t\t\tgl_FragColor = vec4(colour, 1.0);\t\t\t\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/FRAGMENTSHADER]\n"
	"\n"
	"///////////////////////////////////////////////////////////////////////////\n"
	"////                                                                   ////\n"
	"////                   AUXILIARY SHADERS                               ////\n"
	"////                                                                   ////\n"
	"///////////////////////////////////////////////////////////////////////////\n"
	"\n"
	"//\n"
	"// Renders the geometry using a texture\n"
	"//\n"
	"[EFFECT] \n"
	"\tNAME \tRenderSimpleTexture\n"
	"\t\t\n"
	"\t// GLOBALS UNIFORMS\n"
	"\tUNIFORM uWorldViewProjMatrix\t\tWORLDVIEWPROJECTION\n"
	"\t\n"
	"\tUNIFORM sTexture\t\t\t\t\tTEXTURE0\n"
	"\t\n"
	"\t// ATTRIBUTES\n"
	"\tATTRIBUTE inVertex\t\t\t\t\tPOSITION\n"
	"\tATTRIBUTE\tinTexCoord\t\t\t\tUV\t\n"
	"\n"
	"\t// SHADERS\t\n"
	"\tVERTEXSHADER   TextureVertexShader\n"
	"\tFRAGMENTSHADER TextureFragmentShader\n"
	"[/EFFECT]\n"
	"\n"
	"[VERTEXSHADER]\n"
	"\tNAME \t\tTextureVertexShader\n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tattribute highp   vec3 inVertex;\n"
	"\t\tattribute mediump vec2 inTexCoord;\n"
	"\n"
	"\t\tvarying mediump vec2 vTexCoord;\n"
	"\n"
	"\t\tvoid main() \n"
	"\t\t{ \n"
	"\t\t\t// pass-through position and texture coordinates\n"
	"\t\t\tgl_Position = vec4(inVertex, 1.0);\n"
	"\t\t\tvTexCoord = inTexCoord;\n"
	"\t\t} \n"
	"\t[/GLSL_CODE]\n"
	"[/VERTEXSHADER]\n"
	"\n"
	"[FRAGMENTSHADER] \n"
	"\tNAME \t\tTextureFragmentShader \n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tuniform sampler2D sTexture;\n"
	"\t\tvarying mediump vec2 vTexCoord;\n"
	"\n"
	"\t\tvoid main()\n"
	"\t\t{\n"
	"\t\t\tgl_FragColor = texture2D(sTexture, vTexCoord);\t\t\t\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/FRAGMENTSHADER]\n"
	"\n"
	"\n"
	"//\n"
	"// Renders the geometry using a single channel depth map, \n"
	"// scaling the depth values for visualization purposes.\n"
	"//\n"
	"[EFFECT] \n"
	"\tNAME \tRenderDepthTexture\n"
	"\t\t\n"
	"\t// GLOBALS UNIFORMS\n"
	"\tUNIFORM uWorldViewProjMatrix\tWORLDVIEWPROJECTION\n"
	"\t\n"
	"\tUNIFORM sTexture\t\t\t\tTEXTURE0\n"
	"\t\n"
	"\t// ATTRIBUTES\n"
	"\tATTRIBUTE\tinVertex\t\t\tPOSITION\n"
	"\tATTRIBUTE\tinTexCoord\t\t\tUV\t\n"
	"\n"
	"\t// SHADERS\t\n"
	"\tVERTEXSHADER   TextureVertexShader\n"
	"\tFRAGMENTSHADER DepthTextureFragmentShader\n"
	"[/EFFECT]\n"
	"\n"
	"[FRAGMENTSHADER] \n"
	"\tNAME \t\tDepthTextureFragmentShader \n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tuniform sampler2D sTexture;\n"
	"\t\tvarying mediump vec2 vTexCoord;\n"
	"\n"
	"\t\tvoid main()\n"
	"\t\t{\n"
	"\t\t\thighp vec4 depthTex = texture2D(sTexture, vTexCoord);\n"
	"\t\t\thighp float depth = dot(depthTex, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0));\n"
	"\t\t\tgl_FragColor = vec4(vec3(depth * 5.0), 1.0);\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/FRAGMENTSHADER]\n"
	"\n"
	"\n"
	"//\n"
	"// Renders the geometry using a single colour passed as an uniform.\n"
	"//\n"
	"[EFFECT] \n"
	"\tNAME \tRenderSolidColour\n"
	"\t\t\n"
	"\t// GLOBALS UNIFORMS\n"
	"\tUNIFORM uWorldViewProjMatrix\tWORLDVIEWPROJECTION\n"
	"\tUNIFORM uConstantColour\t\t\tMATERIALCOLORAMBIENT\n"
	"\t\n"
	"\t// ATTRIBUTES\n"
	"\tATTRIBUTE\tinVertex\t\t\tPOSITION\n"
	"\tATTRIBUTE\tinTexCoord\t\t\tUV\n"
	"\n"
	"\t// SHADERS\t\n"
	"\tVERTEXSHADER   VertexShader\n"
	"\tFRAGMENTSHADER SolidColourFragmentShader\n"
	"[/EFFECT]\n"
	"\n"
	"[FRAGMENTSHADER] \n"
	"\tNAME \t\tSolidColourFragmentShader \n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tuniform lowp vec4 uConstantColour;\n"
	"\n"
	"\t\tvoid main()\n"
	"\t\t{\n"
	"\t\t\tgl_FragColor = uConstantColour;\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/FRAGMENTSHADER]\n"
	"\n"
	"[VERTEXSHADER]\n"
	"\tNAME \t\tVertexShader\n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tattribute highp   vec3 inVertex;\n"
	"\t\tattribute mediump vec2 inTexCoord;\n"
	"\n"
	"\t\tuniform  mat4  uWorldViewProjMatrix; \n"
	"\n"
	"\t\tvarying mediump vec2 vTexCoord;\n"
	"\n"
	"\t\tvoid main() \n"
	"\t\t{ \n"
	"\t\t\t// pass-through position and texture coordinates\n"
	"\t\t\tgl_Position = uWorldViewProjMatrix * vec4(inVertex, 1.0);\n"
	"\t\t\tvTexCoord = inTexCoord;\n"
	"\t\t} \n"
	"\t[/GLSL_CODE]\n"
	"[/VERTEXSHADER]\n"
	"\n"
	"//\n"
	"// Renders the geometry using a texture\n"
	"//\n"
	"[EFFECT] \n"
	"\tNAME \tRenderCubeTexture\n"
	"\t\t\n"
	"\t// GLOBALS UNIFORMS\n"
	"\tUNIFORM uWorldViewProjMatrix\tWORLDVIEWPROJECTION\n"
	"\tUNIFORM uWorldIT\t\t\t\tWORLDIT\n"
	"\tUNIFORM uColour\t\t\t\t\tMATERIALCOLORAMBIENT\n"
	"\t\n"
	"\tUNIFORM sTexture\t\t\t\tTEXTURE0\n"
	"\t\n"
	"\t// ATTRIBUTES\n"
	"\tATTRIBUTE\tinVertex\t\t\tPOSITION\n"
	"\tATTRIBUTE\tinNormal\t\t\tNORMAL\n"
	"\tATTRIBUTE\tinTexCoord\t\t\tUV\n"
	"\n"
	"\t// SHADERS\t\n"
	"\tVERTEXSHADER   CubeTextureVertexShader\n"
	"\tFRAGMENTSHADER CubeTextureFragmentShader\n"
	"[/EFFECT]\n"
	"\n"
	"[FRAGMENTSHADER] \n"
	"\tNAME \t\tCubeTextureFragmentShader \n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tuniform samplerCube sTexture;\t\t\n"
	"\t\tuniform lowp vec4 uColour;\n"
	"\t\t\n"
	"\t\tvarying mediump vec3 vNormal;\n"
	"\t\t\n"
	"\t\tvoid main()\n"
	"\t\t{\n"
	"\t\t\tgl_FragColor = textureCube(sTexture, vNormal) * uColour;\n"
	"\t\t}\n"
	"\t[/GLSL_CODE]\n"
	"[/FRAGMENTSHADER]\n"
	"\n"
	"[VERTEXSHADER]\n"
	"\tNAME \t\tCubeTextureVertexShader\n"
	"\n"
	"\t[GLSL_CODE]\n"
	"\t\tattribute highp\tvec3 inVertex;\n"
	"\t\tattribute highp\tvec3 inNormal;\n"
	"\n"
	"\t\tuniform  highp mat4  uWorldViewProjMatrix; \n"
	"\t\tuniform  highp mat3  uWorldIT;\n"
	"\n"
	"\t\tvarying mediump vec3 vNormal;\n"
	"\n"
	"\t\tvoid main() \n"
	"\t\t{ \n"
	"\t\t\t// pass-through position and texture coordinates\n"
	"\t\t\tgl_Position = uWorldViewProjMatrix * vec4(inVertex, 1.0);\n"
	"\t\t\tvNormal = uWorldIT * inNormal;\n"
	"\t\t} \n"
	"\t[/GLSL_CODE]\n"
	"[/VERTEXSHADER]";

// Register effect.pfx in memory file system at application startup time
static CPVRTMemoryFileSystem RegisterFile_effect_pfx("effect.pfx", _effect_pfx, 17289);

// ******** End: effect.pfx ********

