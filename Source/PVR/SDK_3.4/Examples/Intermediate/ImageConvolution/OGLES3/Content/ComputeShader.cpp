// This file was created by Filewrap 1.2
// Little endian mode
// DO NOT EDIT

#include "../PVRTMemoryFileSystem.h"

// using 32 bit to guarantee alignment.
#ifndef A32BIT
 #define A32BIT static const unsigned int
#endif

// ******** Start: ComputeShader.csh ********

// File data
static const char _ComputeShader_csh[] = 
	"#version 310 es\r\n"
	"\r\n"
	"/*********** INPUT DEFINES: THESE MUST BE SELECTED AND DEFINED BY THE PROGRAM ***********/\r\n"
	"/*\r\n"
	"IMAGE_BINDING_INPUT\t\t: Image unit used for the texture that contains the current generation\r\n"
	"IMAGE_BINDING_OUTPUT\t: Image unit used for the texture that contains the current generation\r\n"
	"WG_WIDTH\t\t\t\t: Dimension X of the workgroup size\r\n"
	"WG_HEIGHT\t\t\t\t: Dimension Y of the workgroup size\r\n"
	"FILTER_DISTANCE\t\t\t: Distance from our point that the farthest pixel that will need to be\r\n"
	"\t\t\t\t\t\t  taken into consideration will be, in one direction.\r\n"
	"\t\t\t\t\t\t  I.e for needing no pixels but the target, distance is 0 (degenerate case -\r\n"
	"\t\t\t\t\t\t  no convolution). For all neighbouring, it is 1 (for a total of 9 pixels - 3x3). \r\n"
	"\t\t\t\t\t\t  For 2 neighbouring pixels, it is 2 (for a total of 25 pixels in 2D).\r\n"
	"*/\r\n"
	"\r\n"
	"/* To hardcode, uncomment the following lines and change values as needed.*/\r\n"
	"//#define IMAGE_BINDING_INPUT 0\r\n"
	"//#define IMAGE_BINDING_OUTPUT 1\r\n"
	"//#define WG_WIDTH 16\r\n"
	"//#define WG_HEIGHT 16\r\n"
	"//#define FILTER_RADIUS 2\r\n"
	"/*********************************** END INPUT DEFINES **********************************/\r\n"
	"\r\n"
	"\r\n"
	"#define CACHE_WIDTH (WG_WIDTH + (FILTER_RADIUS - 1) * 2)\r\n"
	"#define CACHE_HEIGHT (WG_HEIGHT + (FILTER_RADIUS - 1) * 2)\r\n"
	"#define CACHE_AREA (CACHE_WIDTH * CACHE_HEIGHT)\r\n"
	"\r\n"
	"\r\n"
	"\r\n"
	"\r\n"
	"uniform layout(rgba8, binding = IMAGE_BINDING_INPUT) readonly highp image2D imageIn;\r\n"
	"uniform layout(rgba8, binding = IMAGE_BINDING_OUTPUT) writeonly highp image2D imageOut;\r\n"
	"const lowp vec3 rgb_to_luminance = vec3(0.3f, 0.59f, 0.11f);\r\n"
	"\r\n"
	"shared lowp vec3 colours[CACHE_AREA];\r\n"
	"#if (defined ERODE || defined DILATE)\r\n"
	"shared lowp float luminances[CACHE_AREA];\r\n"
	"#endif\r\n"
	"\r\n"
	"layout (local_size_x = WG_WIDTH, local_size_y = WG_HEIGHT) in;\r\n"
	"\r\n"
	"/*\r\n"
	" *   -------------------------------------------- CACHING STRATEGY --------------------------------------------\r\n"
	" *   GLSL Compute shaders, DirectX compute shaders and OpenCL all define the concept of \"shared\" or \"local\" memory,\r\n"
	" *   which instructed to be fast, on-chip memory local to a workgroup and shared by all threads (work items et.c.,\r\n"
	" *   depending on terminology). \r\n"
	" *   Much of the optimization of GPGPU programs that have a concept of reading data \"around\" their position in an\r\n"
	" *   input domain is finding the correct strategy to utilize local memory.\r\n"
	" *   In this case, each shader will need to read the input texture at own cell location and all neighbouring cells.\r\n"
	" *   That means that apart from the 1-1 area of the grid that is our workgroup, we also need the border of that area.\r\n"
	" * \r\n"
	" *   It is obvious that it is impossible to have all threads doing 100% the same amount of work, as our total domain\r\n"
	" *   (i.e. the part of the grid that is our workgroup plus its borders) is greater than AND not a multiple of our \r\n"
	" *   workgroup size.\r\n"
	" *\r\n"
	" *   By examining the problem parameters (leaving the math as an exercise to the reader) we also see that, unless our \r\n"
	" *   workgroup is less than 8x4 (which is small enough to be undesirable), the domain is always less than twice the \r\n"
	" *   size of our workgroup.\r\n"
	" *   \r\n"
	" *   In that case, we will exploit that information to avoid any loops and fetch either 1 or 2 texels per thread, \r\n"
	" *   by mapping our 2D local coordinates to a 1D cache area (cache[]), and use each thread to fetch 2 texels, skipping the \r\n"
	" *   ones that are not needed.\r\n"
	" *   In order for that to work, each item does NOT fetch its OWN data from global memory (the texture), but the ones that \r\n"
	" *   the mapping dictates by sequentially getting two items per thread, until we cover the entire sampling area.\r\n"
	" *   \r\n"
	" *   Using the algorithm below, the items will be fetched in the following order (example :4x8 kernel => 6x10 cache) \r\n"
	" *   (0,0), (0,0), (0,1), (0,1), (0,2), (0,2), \r\n"
	" *   (0,3), (0,3), (1,0), (1,0), (1,1), (1,1), \r\n"
	" *   (1,2), (1,2), (1,3), (1,3), (2,0), (2,0),\r\n"
	" *   (2,1), (2,1), (2,2), (2,2), (2,3), (2,3),\r\n"
	" *   (3,0), (3,0), (3,1), (3,1), (3,2), (3,2),\r\n"
	" *   (3,3), (3,3), (4,0), (4,0), (4,1), (4,1),\r\n"
	" *   (4,2), (4,2), (4,3), (4,3), (5,0), (5,0),\r\n"
	" *   (5,1), (5,1), (5,2), (5,2), (5,3), (5,3),\r\n"
	" *   (6,0), (6,0), (6,1), (6,1), (6,2), (6,2),\r\n"
	" *   (6,3), (6,3), (7,0), (7,0), (7,1), (7,1) DONE\r\n"
	" *   THE FOLLOWING THREADS ARE SKIPPED BY THE CACHE INDEX CHECK:\r\n"
	" *   (7,2), (7,2), (7,3), (7,3)\r\n"
	" *\r\n"
	" *   NOTE : This strategy spreads the texture fetching optimally among threads, but introduces a few extra ALU ops. Depending \r\n"
	" *   on a many factors, in case for example ALU instructions were a bottleneck, another strategy might be more suitable, for\r\n"
	" *   example making indexing simpler with fewer ops but paying the cost of less well distributed texture fetches.\r\n"
	" */\r\n"
	" \r\n"
	" /* ************************************************************************************************************************\r\n"
	"  * @Function prefetch_texture_samples\r\n"
	"  * @Input groupid  : The global 2D coordinates of the top-left (0,0) element of our workgroup (used to offset into the image)\r\n"
	"  * @Input lid      : The local 2D coordinates of our work-item\r\n"
	"  * @Input cache_id : The 1D id into our local cache\r\n"
	"  * @Input bounds   : The maximum size of the image\r\n"
	"  * ************************************************************************************************************************/\r\n"
	"void prefetch_item(ivec2 groupid, ivec2 lid, int cache_id, ivec2 bounds)\r\n"
	"{\r\n"
	"\t//Cacge\r\n"
	"\tif (cache_id < CACHE_AREA)\r\n"
	"\t{\r\n"
	"\t\t//idByCacheWidth is the actual y coordinate of the top - left\r\n"
	"\t\tint idByCacheWidth = cache_id / CACHE_WIDTH;\r\n"
	"\t\tivec2 global_offset = ivec2(cache_id - idByCacheWidth * CACHE_WIDTH - 1, idByCacheWidth - 1);\r\n"
	"\t\tivec2 global_coords = groupid + global_offset;\r\n"
	"\t\t\r\n"
	"\t\t//CLAMP-TO-EDGE\r\n"
	"\t\tglobal_coords = clamp(global_coords, ivec2(0,0), bounds-ivec2(1,1));\r\n"
	"\t\t\r\n"
	"\t\tcolours[cache_id] = imageLoad(imageIn, global_coords).xyz;\r\n"
	"#if (defined ERODE || defined DILATE)\r\n"
	"\t\tluminances[cache_id] = dot(rgb_to_luminance, colours[cache_id]);  \r\n"
	"#endif\r\n"
	"\t}\r\n"
	"}\r\n"
	"\r\n"
	"/*\r\n"
	" * Picks the highest luminance value in a 3x3 surrounding and \r\n"
	" * writes the corresping colour as result.\r\n"
	" */\r\n"
	"void main()\r\n"
	"{\r\n"
	"\r\n"
	"//***************** BEGIN COMMON CODE *****************//\r\n"
	"// All the filters will do basically the same steps:\r\n"
	"\r\n"
	"//Step 1: Get globals and values we will need\r\n"
	"\tivec2 image_bounds = imageSize(imageIn);\r\n"
	"\tivec2 global_id = ivec2(gl_GlobalInvocationID.xy);\r\n"
	"\tivec2 local_id = ivec2(gl_LocalInvocationID.xy); \r\n"
	"\t//Global coords of the top left corner of our WG in order to offset to it\r\n"
	"\tivec2 group_coords = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy); \r\n"
	"\t\r\n"
	"\t//We will use this for the caching ids.\r\n"
	"\tint cache_id = (local_id.y * WG_WIDTH + local_id.x) * 2;\r\n"
	"\r\n"
	"//Step 2: Prefetch all needed texels into the fast shared local memory\r\n"
	"\t//Cache two consecutive values per kernel\r\n"
	"\tprefetch_item(group_coords, local_id, cache_id, image_bounds);\r\n"
	"\tprefetch_item(group_coords, local_id, cache_id + 1, image_bounds);\r\n"
	"\t\r\n"
	"//Step 3: SYNCHRONIZE so that the values in the caches are visible to all threads\r\n"
	"\tbarrier();\r\n"
	"\t\r\n"
	"\tvec3 result_colour;\r\n"
	"\r\n"
	"//Step 4: Actually execute the convolutions\r\n"
	"//***************** END COMMON CODE *****************//\r\n"
	"\r\n"
	"#ifdef DILATE\r\n"
	"//********************** DILATE **********************//\r\n"
	"/* Writes to the current pixel tha color of the neighbouring\r\n"
	" * pixel with the HIGHEST luminance*/\r\n"
	"\r\n"
	"\t//Find the max of these values\r\n"
	"\tint max_idx = local_id.y * CACHE_WIDTH + local_id.x;\t\t\t\t\t\t\t\t\t\t//(0,0)\r\n"
	"\tint idx = max_idx + 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//(0,1)\r\n"
	"\t\t\t\t\t\t\tmax_idx = luminances[idx] > luminances[max_idx] ? idx : max_idx;\r\n"
	"\tidx += 1;\t\t\t\tmax_idx = luminances[idx] > luminances[max_idx] ? idx : max_idx;\t//(0,2)\r\n"
	"\tidx += CACHE_WIDTH;\t\tmax_idx = luminances[idx] > luminances[max_idx] ? idx : max_idx; \t//(1,2)\r\n"
	"\tidx -= 1;\t\t\t\tmax_idx = luminances[idx] > luminances[max_idx] ? idx : max_idx;\t//(1,1)\r\n"
	"\tidx -= 1;\t\t\t\tmax_idx = luminances[idx] > luminances[max_idx] ? idx : max_idx;\t//(1,0)\r\n"
	"\tidx += CACHE_WIDTH;\t\tmax_idx = luminances[idx] > luminances[max_idx] ? idx : max_idx;\t//(2,0)\r\n"
	"\tidx += 1;\t\t\t\tmax_idx = luminances[idx] > luminances[max_idx] ? idx : max_idx;\t//(2,1)\r\n"
	"\tidx += 1;\t\t\t\tmax_idx = luminances[idx] > luminances[max_idx] ? idx : max_idx;\t//(2,2)\r\n"
	"\r\n"
	"\tresult_colour = colours[max_idx];\r\n"
	"#endif //DILATE\r\n"
	"\r\n"
	"#ifdef ERODE\r\n"
	"//********************** ERODE **********************//\r\n"
	"/* Writes to the current pixel tha color of the neighbouring\r\n"
	" * pixel with the LOWEST luminance*/\r\n"
	"\r\n"
	"\t//Find the min of these values\r\n"
	"\tint min_idx = local_id.y * CACHE_WIDTH + local_id.x;\t\t\t\t\t\t\t\t\t//(0,0)\r\n"
	"\tint idx = min_idx + 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//(0,1)\r\n"
	"\tmin_idx = luminances[idx] < luminances[min_idx] ? idx : min_idx;\r\n"
	"\tidx += 1;\t\t\t\tmin_idx = luminances[idx] < luminances[min_idx] ? idx : min_idx;  //(0,2)\r\n"
	"\tidx += CACHE_WIDTH;\t\tmin_idx = luminances[idx] < luminances[min_idx] ? idx : min_idx; \t//(1,2)\r\n"
	"\tidx -= 1;\t\t\t\tmin_idx = luminances[idx] < luminances[min_idx] ? idx : min_idx;\t//(1,1)\r\n"
	"\tidx -= 1;\t\t\t\tmin_idx = luminances[idx] < luminances[min_idx] ? idx : min_idx;\t//(1,0)\r\n"
	"\tidx += CACHE_WIDTH;\t\tmin_idx = luminances[idx] < luminances[min_idx] ? idx : min_idx;\t//(2,0)\r\n"
	"\tidx += 1;\t\t\t\tmin_idx = luminances[idx] < luminances[min_idx] ? idx : min_idx;\t//(2,1)\r\n"
	"\tidx += 1;\t\t\t\tmin_idx = luminances[idx] < luminances[min_idx] ? idx : min_idx;\t//(2,2)\r\n"
	"\r\n"
	"\tresult_colour = colours[min_idx];\r\n"
	"#endif //ERODE\r\n"
	"\r\n"
	"#if (defined GRADIENT_LAPLACE || defined EDGEDETECT_LAPLACE)\r\n"
	"//********************** LAPLACIAN EDGE DETECTION **********************//\r\n"
	"/* This is a simplistic convolution kernel for edge detection. It is not\r\n"
	" * frequently used as it is extremely sensitive to noise.\r\n"
	" * Edge detection convolution typically works by calculating the gradient\r\n"
	" * of an image in \"some\" direction, in that case the horizontal, vertical\r\n"
	" * AND diagonal at the same time. Note, that the sum of all weights is zero,\r\n"
	" * and that we are, effectively, calculating gradients.\r\n"
	" */\r\n"
	"\r\n"
	"\tlowp float w[] = \r\n"
	"\tfloat[](- .7071, -1.    , - .7071,\r\n"
	"\t  -1.    ,  6.8284, -1.    ,\r\n"
	"\t  - .7071, -1.    , - .7071);\r\n"
	"\t//Normally we need to multiply all neighbouring pixels with the widths, but we of course can omit zeros so we are a little less verbose\r\n"
	"\tint idx = (local_id.y + 1) * CACHE_WIDTH + local_id.x + 1;\t\r\n"
	"\r\n"
	"\tresult_colour =\t w[0]*colours[idx - CACHE_WIDTH -1] + w[1]*colours[idx - CACHE_WIDTH] + w[2]*colours[idx - CACHE_WIDTH +1];\r\n"
	"\tresult_colour += w[3]*colours[idx               -1]\t+ w[4]*colours[idx              ] + w[5]*colours[idx               +1];\r\n"
	"\tresult_colour += w[6]*colours[idx + CACHE_WIDTH -1] + w[7]*colours[idx + CACHE_WIDTH] + w[8]*colours[idx + CACHE_WIDTH +1];\r\n"
	"\tresult_colour = abs(result_colour);\r\n"
	"#endif //EDGEDETECT_LAPLACE\r\n"
	"\r\n"
	"#if (defined GRADIENT_SOBEL || defined EDGEDETECT_SOBEL)\r\n"
	"//********************** SOBEL EDGE DETECTION **********************//\r\n"
	"/* This is a convolution kernel that is frequently used for edge detection. \r\n"
	" * It is not as sensitive to noise, and is frequently used modified or unmodified\r\n"
	" * in actual production code, though usually the results are post-processed for\r\n"
	" * the actual application (clamped, enhanced et.c.) to detect actual edges\r\n"
	" * There are Sobel convolution kernels to detects edges in any direction facing \r\n"
	" * a \"compass point\" (by rotating the values clockwise or counterclockwise). The\r\n"
	" * most common use, though, is by detecting the x and y ones. We also do not\r\n"
	" * need the \"reverse\" passes, as we can get the absolute values, in which case \r\n"
	" * obviously both left - to - right and right - to - left gradients are detected.\r\n"
	" * The formula G=sqrt(Gx^2+Gy^2) is fine for most practical purposes.\r\n"
	" */\r\n"
	"\r\n"
	"\tlowp float  sx[] = float[]\r\n"
	"\t(-1., 0.,  1.,\r\n"
	"\t -2., 0.,  2.,\r\n"
	"\t -1., 0.,  1.);\r\n"
	"\tlowp float  sy[] = float[]\r\n"
	"\t(-1.,-2.,-1.,\r\n"
	"\t  0., 0., 0.,\r\n"
	"\t  1., 2., 1.);\r\n"
	"\r\n"
	"\t//Sx calculates the horizontal gradient, Sy the vertical gradient. The actual total gradient G = sqrt(gx^2 + gy^2)\r\n"
	"\tint idx = (local_id.y + 1) * CACHE_WIDTH + local_id.x + 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//(0,1)\r\n"
	"\r\n"
	"\tlowp vec3 gx;\r\n"
	"\tgx  = colours[idx - CACHE_WIDTH - 1] * sx[0] + /*colours[idx - CACHE_WIDTH] * sx[1]*/ + colours[idx - CACHE_WIDTH + 1] * sx[2];\r\n"
	"\tgx += colours[idx               - 1] * sx[3] + /*colours[idx              ] * sx[4]*/ + colours[idx               + 1] * sx[5];\r\n"
	"\tgx += colours[idx + CACHE_WIDTH - 1] * sx[6] + /*colours[idx + CACHE_WIDTH] * sx[7]*/ + colours[idx + CACHE_WIDTH + 1] * sx[8];\r\n"
	"\r\n"
	"\t// vertical filter\r\n"
	"\tlowp vec3 gy;\r\n"
	"\t  gy  = colours[idx - CACHE_WIDTH - 1] * sx[0] + colours[idx - CACHE_WIDTH] * sx[1] + colours[idx - CACHE_WIDTH + 1] * sx[2];\r\n"
	"\t/*gy += colours[idx               - 1] * sx[3] + colours[idx              ] * sx[4] + colours[idx               + 1] * sx[5];*/\r\n"
	"\t  gy += colours[idx + CACHE_WIDTH - 1] * sx[6] + colours[idx + CACHE_WIDTH] * sx[7] + colours[idx + CACHE_WIDTH + 1] * sx[8];\r\n"
	"\r\n"
	"\tresult_colour = sqrt(gx*gx + gy*gy);\r\n"
	"#endif //EDGEDETECT_SOBEL\r\n"
	"\r\n"
	"//#if (defined EDGEDETECT_SOBEL||defined EDGEDETECT_LAPLACE)\r\n"
	"//////In order to actually DETECT the edges in a \"boolean\" fashion, we take the magnitude of the color and threshold it\r\n"
	"//lowp float s = clamp(dot(result_colour, rgb_to_luminance)-.25 * .5);\r\n"
	"//result_colour = vec3(s,s,s);\r\n"
	"//#endif\r\n"
	"\r\n"
	"#ifdef GAUSSIAN\r\n"
	"//**********************------------ GAUSSIAN BLUR -------------**********************//\r\n"
	"/* This is a convolution kernel that performs a gaussian blur FOR ILLUSTRATION PURPOSES \r\n"
	" * ONLY. It is very rarely used in this form, or as a multipass in general, because: the \r\n"
	" * 1) It is separable, meaning that it can be composed by 2 1D passes, one horizontal and\r\n"
	" * one vertical. As the 2D pass requires the SQUARE of the samples that the 1D needs, it\r\n"
	" * is much, much more preferable, especially for kernels larger than the 3x3 we use here \r\n"
	" * 2) Multiple passes are identical as doing one pass with a larger radius. It should be\r\n"
	" * obvious that instead of doing a radius 4 pass that will require 7x7 = 49 samples per \r\n"
	" * texel, it is quite preferable to do two passes, requiring a total of 7+7 = 14 samples\r\n"
	" * per texel...\r\n"
	" */\r\n"
	"\r\n"
	"\tlowp float  g[] = float[]\r\n"
	"\t(0.0625, 0.1250,  0.0625,\r\n"
	"\t 0.1250, 0.2500,  0.1250,\r\n"
	"\t 0.0625, 0.1250,  0.0625);\r\n"
	"\r\n"
	"\t//Sx calculates the horizontal gradient, Sy the vertical gradient. The actual total gradient G = sqrt(gx^2 + gy^2)\r\n"
	"\tint idx = (local_id.y + 1) * CACHE_WIDTH + local_id.x +1;\r\n"
	"\tresult_colour  = colours[idx - CACHE_WIDTH - 1] * g[0] + colours[idx - CACHE_WIDTH] * g[1] + colours[idx - CACHE_WIDTH + 1] * g[2];\r\n"
	"\tresult_colour += colours[idx               - 1] * g[3] + colours[idx              ] * g[4] + colours[idx               + 1] * g[5];\r\n"
	"\tresult_colour += colours[idx + CACHE_WIDTH - 1] * g[6] + colours[idx + CACHE_WIDTH] * g[7] + colours[idx + CACHE_WIDTH + 1] * g[8];\r\n"
	"#endif //GAUSSIAN\r\n"
	"\r\n"
	"#ifdef EMBOSS\r\n"
	"//**********************------------ EMBOSS -------------**********************//\r\n"
	"/* Emboss effect */\r\n"
	"\r\n"
	"\tlowp float  g[] = float[]\r\n"
	"\t(-2, -1,  0,\r\n"
	"\t -1, 1,  1,\r\n"
	"\t  0, 1,  2);\r\n"
	"\r\n"
	"\t//Sx calculates the horizontal gradient, Sy the vertical gradient. The actual total gradient G = sqrt(gx^2 + gy^2)\r\n"
	"\tint idx = (local_id.y + 1) * CACHE_WIDTH + local_id.x +1;\r\n"
	"\tresult_colour  = colours[idx - CACHE_WIDTH - 1] * g[0] + colours[idx - CACHE_WIDTH] * g[1] + colours[idx - CACHE_WIDTH + 1] * g[2];\r\n"
	"\tresult_colour += colours[idx               - 1] * g[3] + colours[idx              ] * g[4] + colours[idx               + 1] * g[5];\r\n"
	"\tresult_colour += colours[idx + CACHE_WIDTH - 1] * g[6] + colours[idx + CACHE_WIDTH] * g[7] + colours[idx + CACHE_WIDTH + 1] * g[8];\r\n"
	"#endif //EMBOSS\r\n"
	"\r\n"
	"#ifdef SHARPEN\r\n"
	"//**********************------------ SHARPEN -------------**********************//\r\n"
	"/* Sharpen effect */\r\n"
	"\r\n"
	"\tlowp float  g[] = float[]\r\n"
	"\t(-.2,-.28284,-.2,\r\n"
	"\t  -.28284, 2.931, -.28284,\r\n"
	"\t -.2,-.28284,-.2);\r\n"
	"\r\n"
	"\t//Sx calculates the horizontal gradient, Sy the vertical gradient. The actual total gradient G = sqrt(gx^2 + gy^2)\r\n"
	"\tint idx = (local_id.y + 1) * CACHE_WIDTH + local_id.x +1;\r\n"
	"\tresult_colour  = colours[idx - CACHE_WIDTH - 1] * g[0] + colours[idx - CACHE_WIDTH] * g[1] + colours[idx - CACHE_WIDTH + 1] * g[2];\r\n"
	"\tresult_colour += colours[idx               - 1] * g[3] + colours[idx              ] * g[4] + colours[idx               + 1] * g[5];\r\n"
	"\tresult_colour += colours[idx + CACHE_WIDTH - 1] * g[6] + colours[idx + CACHE_WIDTH] * g[7] + colours[idx + CACHE_WIDTH + 1] * g[8];\r\n"
	"#endif //SHARPEN\r\n"
	"\r\n"
	"\timageStore(imageOut, global_id, vec4(result_colour,1.));\r\n"
	"}\r\n";

// Register ComputeShader.csh in memory file system at application startup time
static CPVRTMemoryFileSystem RegisterFile_ComputeShader_csh("ComputeShader.csh", _ComputeShader_csh, 16379);

// ******** End: ComputeShader.csh ********

